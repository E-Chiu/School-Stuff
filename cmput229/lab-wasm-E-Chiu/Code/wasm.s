#
# CMPUT 229 Student Submission License
# Version 1.0
# Copyright 2019 Ethan Chiu
#
# Redistribution is forbidden in all circumstances. Use of this
# software without explicit authorization from the author or CMPUT 229
# Teaching Staff is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 229 - Computer Organization and Architecture I at the University of
# Alberta, Canada. This solution is confidential and remains confidential 
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including 
# the URL or other repository locating information, to the following email
# address:
#
#          cmput229@ualberta.ca
#
#---------------------------------------------------------------
# CCID:                 echiu
# Lecture Section:      A1
# Instructor:           Nelson Amaral
# Lab Section:          D07
# Teaching Assistant:   Amir Karimi
#---------------------------------------------------------------
# 

.include "common.s"

#----------------------------------
#        STUDENT SOLUTION
#----------------------------------
.data
fwdBranchTable:	.space 8000
bwdBranchTable:	.space 8000

.align 2

.text
#---------------------------------------------------------------------------------------------------------------------------#
# RISCVtoWASM
# This function translates the binary representation of a RISC-V program into the binary representation of a WASM program.
# Arguments:
# a0: pointer to memory containing the binary representation of a RISC-V function. The end of the RISC-V program is marked 
# by the sentinel word 0xFFFFFFFF (The integer -1).
# a1: pointer to pre-allocated memory where the generated WASM binary representation of a function must be stored.
# Return Values:
# a0: The number of bytes of WASM code that were generated by the function.
# Side Effects:
# The generated WASM binary representation of the RISC-V function is stored in the pre-allocated memory specified by a1. 
# The end of the binary representation MUST BE the instruction (return (get_local 0)) followed by the end opcode.
#-------------------------------------------------------------------------------------------------------------------------#
RISCtoWASM:
	addi sp, sp, -20
	sw ra, 0(sp)
	sw s0, 4(sp)					# address to write to
	sw s1, 8(sp)					# start of risc instruction
	sw s2, 12(sp)					# actual address to increment
	sw s3, 16(sp)					# used to store current instr
	mv s0, a1
	mv s1, a0
	mv s2, a0
	jal ra, generateTargetTable			# generate table
	lw s3, 0(s1)					# get first instruction
RISCtoWASMLoop:
	slli t0, s3, 25
	srli t0, t0, 25					# isolate opcode
	li t1, 0x33					# opcode for R type
	beq t0, t1, RISCtoWASMJumpR			# if R type parse instr as R
	li t1, 0x13					# opcode for I type
	beq t0, t1, RISCtoWASMJumpI			# if I type parse instr as I
	li t1, 0x63					# opcode for SB
	beq t0, t1, RISCtoWASMJumpSB			# if SB type parse instr as SB
RISCtoWASMJumpR:
	mv a0, s0
	mv a1, s2
	li a2, 0xe000
	and a2, a2, s3					# isolate func
	li t0, 0xe000
	beq t0, a2, RISCtoWASMJumpRAnd
	li t0, 0xc000
	beq t0, a2, RISCtoWASMJumpROr
	li t0, 0xa000
	beq t0, a2, RISCtoWASMJumpRSrl
	li t0, 0x2000
	beq t0, a2, RISCtoWASMJumpRSll
	li a2, 0xFE000000
	and a2, a2, s3
	beqz a2, RISCtoWASMJumpRAdd
	b RISCtoWASMJumpRSub
RISCtoWASMJumpRAnd:
	li a2, 0x6a					# load opcode
	b RISCtoWASMREnd				# jump to end
RISCtoWASMJumpROr:
	li a2, 0x72
	b RISCtoWASMREnd
RISCtoWASMJumpRSrl:
	li a2, 0x76
	b RISCtoWASMREnd
RISCtoWASMJumpRSll:
	li a2, 0x74
	b RISCtoWASMREnd
RISCtoWASMJumpRAdd:
	li a2, 0x6a
	b RISCtoWASMREnd
RISCtoWASMJumpRSub:
	li a2, 0x6b					
	b RISCtoWASMREnd
RISCtoWASMREnd:
	jal ra, translateRType
	add s0, s0, a0					# add bytes used
	b RISCtoWASMCheckTarget				# check target
RISCtoWASMJumpI:
	mv a0, s0					# move address to write to
	mv a1, s2					# move address of current instruction
	li a2, 0x7000
	and a2, a2, s3					# isolate func
	li t1, 0x7000
	beq t1, a2, RISCtoWASMJumpIAndi
	li t1, 0x6000
	beq t1, a2, RISCtoWASMJumpIOri
	beqz a2, RISCtoWASMJumpIAddi
	li t1, 0x1000
	beq t1, a2, RISCtoWASMJumpISlli
	li t1, 0xf0000000
	and a2, t1, s3
	beqz a2, RISCtoWASMJumpISrli
	b RISCtoWASMJumpISrai	
RISCtoWASMJumpIAndi:
	li a2, 0x71
	b RISCtoWASMIEnd
RISCtoWASMJumpIOri:
	li a2, 0x72
	b RISCtoWASMIEnd
RISCtoWASMJumpIAddi:
	li a2, 0x6a
	b RISCtoWASMIEnd
RISCtoWASMJumpISlli:
	li a2, 0x74
	b RISCtoWASMIEnd
RISCtoWASMJumpISrli:
	li a2, 0x76
	b RISCtoWASMIEnd
RISCtoWASMJumpISrai:
	li a2, 0x75
	b RISCtoWASMIEnd
RISCtoWASMIEnd:
	jal ra, translateIType
	add s0, s0, a0					# add bytes used
	b RISCtoWASMCheckTarget				# check target
RISCtoWASMJumpSB:
	mv a0, s0
	mv a1, s2
	li a2, 0x7000
	and a2, a2, s3					# isolate func
	beqz a2, RISCtoWASMJumpSBEq
	li a2, 0x4e
	b RISCtoWASMJumpSBEnd
RISCtoWASMJumpSBEq:
	li a2, 0x46
RISCtoWASMJumpSBEnd:
	jal ra, translateBranch
	add s0, s0, a0
	b RISCtoWASMCheckTarget
RISCtoWASMCheckTarget:
	mv a0, s1					# move start address
	mv a1, s2					# move instruction address
	addi a1, a1, 4
	li a2, 1					# ask for forward addresses
	jal ra, readTargetCount				# get forwards count
	beqz a0, RISCtoWASMAskBwd			# if 0 skip adding
RISCtoWASMAddFwd:
	li t0, 0x0b
	sb t0, 0(s0)					# add end
	addi s0, s0, 1
	addi a0, a0, -1 
	bgtz a0, RISCtoWASMAddFwd			# loop until all ends added
RISCtoWASMAskBwd:
	mv a0, s1
	mv a1, s2
	addi a1, a1, 4
	li a2, 0					# ask for backwards count
	jal ra, readTargetCount				# get backwards count
	beqz a0, RISCtoWASMGetNext			# if 0 skip adding
RISCtoWASMAddBwd:
	li t0, 0x03
	sb t0, 0(s0)					# add loop
	addi, s0, s0, 1
	li t0, 0x40
	sb t0, 0(s0)
	addi, s0, s0, 1					# add void
	addi a0, a0, -1
	bgtz a0, RISCtoWASMAddBwd			# loop until all loops added
RISCtoWASMGetNext:
	addi s2, s2, 4
	lw s3, 0(s2)					# load next instr
	li t1, -1
	bne t1, s3, RISCtoWASMLoop			# repeat if not -1
RISCtoWASMEnd:
	li t1, 0x20
	sb t1, 0(s0)					# store get local
	addi s0, s0, 1
	li t1, 0x00
	sb t1, 0(s0)					# store 0
	addi s0, s0, 1					
	li t1, 0x0f
	sb t1, 0(s0)					# store return
	addi s0, s0, 1
	li t1, 0x0b
	sb t1, 0(s0)					# store end
	addi s0, s0, 1
	sub a0, s2, s1					# get num of bytes
	lw s3, 16(sp)
	lw s2, 12(sp)
	lw s1, 8(sp)
	lw s0, 4(sp)
	lw ra, 0(sp)
	addi sp, sp, 20
	jr ra						# return	
#-------------------------------------------------------------------------------------------------------------------------#
# translateIType
# This function translates an I-Type RISC-V instruction into WASM. It also writes the translated instruction to the binary
# representation of the WASM code. It is guaranteed that only valid I-Type instructions will be passed to this function when grading.
# Arguments:
# a0: Address to write instruction representation translated into WASM.
# a1: Address of the RISC-V instruction to parse.
# a2: WASM opcode for the WASM instruction to build. NOT the RISC-V opcode for the instruction.
# Return Values:
# a0: The number of bytes in the translated WASM instruction.
# Side Effects:
# The translated instruction is written in the address specified by a0.
#-------------------------------------------------------------------------------------------------------------------------#
translateIType:
	addi sp, sp, -24
	sw ra, 0(sp)
	sw s0, 4(sp) 					# address to write to
	sw s1, 8(sp)					# address of instr to add
	sw s2, 12(sp)					# opcode
	sw s3, 16(sp)					# other stuff
	sw s4, 20(sp)					# original address
	mv s0, a0
	mv s4, a0
	mv s1, a1
	mv s2, a2					# move return values
	lw s3, 0(s1)					# get instruction from address
	li t2, 0x7000
	and t3, s3, t2					# isolate rs1
	srli t3, t3, 15
	beqz t3, translateITypeZero			# zero register
	li t1, 0x20
	sb t1 0(s0)					# store get_local
	addi s0, s0, 1
	addi t1, t3, -10
	li t2, 10
	blt t1, t2, translateITypeTen			# register < 10
	sb t1, 0(s0)					# store rs
	addi s0, s0, 1
	b translateITypeImm
translateITypeZero:
	li t1, 0x41
	sb t1, 0(s0)					# store i32.const
	addi s0, s0, 1
	li t1, 0x00
	sb t1, 0(s0)
	addi s0, s0, 1					# store 0
	b translateITypeImm				# go to next step
translateITypeTen:
	addi, t1, t1, 17				# get wasm representation
	sb t1, 0(s0)
	addi s0, s0, 1
translateITypeImm:
	li t1, 0x74
	beq t1, s2, translateITypeImmShift
	li t1, 0x75
	beq t1, s2, translateITypeImmShift
	li t1, 0x76
	beq t1, s2, translateITypeImmShift		# branch for shifts with different immediates
	li t1, 0xfff00000
	and a0, t1, s3					# isolate imm
	srai a0, a0, 20					# move immediate to end
	jal ra, encodeLEB128				# get leb128 representation of imm
	b translateITypeImmD
translateITypeImmShift:
	li t1, 0xf00000
	and a0, t1, s3
	jal ra, encodeLEB128				# get leb128 representation of imm for shift
translateITypeImmD:
	li t1, 0x41
	sb t1, 0(s0)					# store 132.const
	addi s0, s0, 1
	sb a0, 0(s0)					# store immediate
	addi s0, s0, 1					# add byte difference
	li t1, 1
	beq a1, t1, translateITypeAddImm		# if only one byte only need to add once
	srli a0, a0, 8					# get second byte
	sb a0, 0(s0)
	addi s0, s0, 1
translateITypeAddImm:
	sb s2, 0(s0)					# store op
	addi s0, s0, 1
	li t1, 0x21
	sb t1, 0(s0)					# store set_local
	addi s0, s0, 1
	li t1, 0xf80
	and t1, s3, t1					# isolate rd
	srli t1, t1, 7
	li t2, 10
	blt t1, t2, translateITypeDest			# special register
	addi t1, t1, -10
	sb t1, 0(s0)					# store rd
	addi s0, s0, 1
	b translateITypeEnd
translateITypeDest:
	addi t1, t1, 17
	sb t1, 0(s0)					# store correct representation
	addi s0, s0, 1
translateITypeEnd:
	sub a0, s0, s4					# get number of bytes used
	lw s4, 20(sp)
	lw s3, 16(sp)
	lw s2, 12(sp)
	lw s1, 8(sp)
	lw s0, 4(sp)
	lw ra, 0(sp)
	addi sp, sp, 24
	jr ra						# return

#-------------------------------------------------------------------------------------------------------------------------#
# translateRType
# This function translates an R-Type RISC-V instruction into WASM. It also writes the translated instruction to the binary
# representation of the WASM code. It is guaranteed that only valid R-Type instructions will be passed to this function when grading.
# Arguments:
# a0: Address to write instruction representation translated into WASM.
# a1: Address of the RISC-V instruction to parse.
# a2: Opcode for the WASM instruction to build. NOT the RISC-V opcode for the instruction.
# Return Values:
# a0: The number of bytes in the translated WASM instruction.
# Side Effects:
# The translated instruction is written in the address specified by a0.
#-------------------------------------------------------------------------------------------------------------------------#
translateRType:
	addi sp, sp, -16
	sw ra, 0(sp)
	sw s0, 4(sp)					# original address
	sw s1, 8(sp)
	sw s3, 12(sp)
	mv s0, a0
	lw t0, 0(a1)					# get instruction from address
	li t1, 0xf8000
	and t3, t0, t1					# isolate rs1
	srli t3, t3, 15
	li s3, 2					# loop counter
translateRTypeReg:
	beqz t3, translateRTypeZero			# zero register
	li t1, 0x20
	sb t1 0(a0)					# store get_local
	addi a0, a0, 1
	li t2, 10
	blt t3, t2, translateRTypeTen			# register < 10
	addi t1, t3, -10
	sb t1, 0(a0)					# store rs
	addi a0, a0, 1
translateRTypeSpecial:
	li t1, 0x1f00000
	and t3, t1, t0					# isolate rs2
	srli t3, t3, 20
	addi s3, s3, -1
	bnez s3, translateRTypeReg			# do for second register	
	b translateRTypeOp
translateRTypeZero:
	li t1, 0x41
	sb t1, 0(a0)					# store i32.const
	addi a0, a0, 1
	li t1, 0x00
	sb t1, 0(a0)
	addi a0, a0, 1					# store 0
	b translateRTypeSpecial				# go to next step
translateRTypeTen:
	addi, t1, t3, 17				# get wasm representation
	sb t1, 0(a0)
	addi a0, a0, 1
	b translateRTypeSpecial				# go back
translateRTypeOp:
	sb a2, 0(a0)					# store op
	addi a0, a0, 1
	li t1, 0x21
	sb t1, 0(a0)					# store set_local
	addi a0, a0, 1
	li t1, 0xf80
	and t1, t0, t1					# isolate rd
	srli t1, t1, 7
	li t2, 10
	blt t1, t2, translateRTypeDest			# special register
	addi t1, t1, -10
	sb t1, 0(a0)					# store rd
	addi a0, a0, 1
	b translateRTypeEnd
translateRTypeDest:
	addi t1, t1, 17
	sb t1, 0(a0)					# store correct representation
	addi a0, a0, 1
translateRTypeEnd:
	sub a0, a0, s0					# get number of bytes used
	lw s3, 12(sp)
	lw s1, 8(sp)
	lw s0, 4(sp)
	lw ra, 0(sp)
	addi sp, sp, 16
	jr ra						# return
#-------------------------------------------------------------------------------------------------------------------------#
#translateBranch
# This function translates a branch RISC-V instruction into WASM, with special care being taking to account for differences 
# in forward and backward branches. It also writes the translated instruction to the binary representation of the WASM code. 
# It is guaranteed that only valid branch instructions will be passed to this function when grading.
# Arguments:
# a0: Address to write instruction representation translated into WASM.
# a1: Address of the RISC-V instruction to parse.
# a2: Opcode for the WASM instruction to build. NOT the RISC-V opcode for the instruction.
# Return Values:
# a0: The number of bytes in the translated WASM instruction.
# Side Effects:
# The translated instruction is written in the address specified by a0.
#-------------------------------------------------------------------------------------------------------------------------#
translateBranch:
	addi sp, sp, -4
	sw s0, 0(sp)					# a0
	mv s0, a0
	lw t0, 0(a1)					# get instruction from address
	li t3, 0xf00
	and t1, t0, t3					# immediate bits 1-4
	add t2, t1, zero
	srli t2, t2, 7					# put immediate into t2 and shift 1 to account for implicit 0 bit
	li t3, 0x7e000000
	and t1, t0, t3					# immediate bits 5-10
	srli t1, t1, 20					# move to correct spot
	or t2, t1, t2					# add bits 0-10 all together
	andi t1, t0, 0x80				# immediate bit 11
	slli t1, t1, 4					# move to correct spot
	or t2, t1, t2					# add bits 0-11 all together
	li t3, 0x80000000
	and t1, t0, t3					# immediate bit 12
	srai t1, t1, 19					# move to correct spot while sign extending
	or t6, t1, t2					# get full immediate
	bltz t6, translateBranchBwd			# if immediate < 0 do backward branch
	li t1, 0x02
	sb t1, 0(a0)					# start block
	addi a0, a0, 1
	li t1, 0x40
	sb t1, 0(a0)					# add void
	addi a0, a0, 1
	li t1, 0xf8000
	and t3, t0, t1					# isolate rs1
	srli t3, t3, 15
	li t6, 2					# loop counter
translateBranchFwdReg:
	beqz t3, translateBranchFwdZero			# zero register
	li t1, 0x20
	sb t1 0(a0)					# store get_local
	addi a0, a0, 1
	li t2, 10
	blt t3, t2, translateBranchFwdTen		# register < 10
	addi t1, t3, -10
	sb t1, 0(a0)					# store rs
	addi a0, a0, 1
translateBranchFwdSpecial:
	li t1, 0x1f00000
	and t3, t1, t0					# isolate rs2
	srli t3, t3, 20
	addi t6, t6, -1
	bnez t6, translateBranchFwdReg			# do for second register
	sb a2, 0(a0)					# add op
	addi a0, a0, 1
	b translateBranchFwdBr
translateBranchFwdZero:
	li t1, 0x41
	sb t1, 0(a0)					# store i32.const
	addi a0, a0, 1
	li t1, 0x00
	sb t1, 0(a0)
	addi a0, a0, 1					# store 0
	b translateBranchFwdSpecial			# go to next step
translateBranchFwdTen:
	addi, t1, t3, 17				# get wasm representation
	sb t1, 0(a0)
	addi a0, a0, 1
	b translateBranchFwdSpecial			# go back
translateBranchFwdBr:
	li t1, 0x0d
	sb t1, 0(a0)					# store br_if
	addi a0, a0, 1
	li t1, 0x00
	sb t1, 0(a0)					# store 0
	addi a0, a0, 1
	b translateBranchEnd
translateBranchBwd:
	li t1, 0xf8000
	and t3, t0, t1					# isolate rs1
	srli t3, t3, 15
	li t6, 2					# loop counter
translateBranchBwdReg:
	beqz t3, translateBranchBwdZero			# zero register
	li t1, 0x20
	sb t1 0(a0)					# store get_local
	addi a0, a0, 1
	li t2, 10
	blt t3, t2, translateBranchBwdTen		# register < 10
	addi t1, t3, -10
	sb t1, 0(a0)					# store rs
	addi a0, a0, 1
translateBranchBwdSpecial:
	li t1, 0x1f00000
	and t3, t1, t0					# isolate rs2
	srli t3, t3, 20
	addi t6, t6, -1
	bnez t6, translateBranchBwdReg			# do for second register
	sb a2, 0(a0)					# add op
	addi a0, a0, 1	
	b translateBranchBwdBr
translateBranchBwdZero:
	li t1, 0x41
	sb t1, 0(a0)					# store i32.const
	addi a0, a0, 1
	li t1, 0x00
	sb t1, 0(a0)
	addi a0, a0, 1					# store 0
	b translateBranchBwdSpecial			# go to next step
translateBranchBwdTen:
	addi, t1, t3, 17				# get wasm representation
	sb t1, 0(a0)
	addi a0, a0, 1
	b translateBranchBwdSpecial			# go back
translateBranchBwdBr:
	li t1, 0x0d
	sb t1, 0(a0)					# store br_if
	addi a0, a0, 1
	li t1, 0x00
	sb t1, 0(a0)					# store 0
	addi a0, a0, 1
	li t1, 0x0b
	sb t1, 0(a0)					# store end
	addi a0, a0, 1
	b translateBranchEnd
translateBranchEnd:
	sub a0, a0, s0					# get number of bytes used
	lw s0, 0(sp)
	addi sp, sp, 4
	jr ra						# return
#-------------------------------------------------------------------------------------------------------------------------#
# encodeLEB128
# This function converts a 12-bit two-complement value into LEB128 representation.
# Arguments:
# a0: A 12-bit two-complement value, stored in the lower half of the word, to be converted into LEB128 representation.
# Return Values:
# a0: The LEB128 representation of the input value.
# a1: The number of bytes that were needed to represent the resulting LEB128 formatted value.
#-------------------------------------------------------------------------------------------------------------------------#
encodeLEB128:
	li a1, 1					# assume only 1 byte
	slli t0, a0, 20					# 00000000000000000010000000000000					
	srai t0, t0, 20					# sign extend
	slli t0, t0, 18
	srli t0, t0, 18					# cut to 14 bits
	andi t1, t0, 0x7f				# get first 7 bits
	mv a0, t1					# copy to a0
	andi t2, t0, 0xc0				# get the 7th and 8th bits
	li a1, 1					# 1 byte needed
	beqz t2, encodeLEB128Finish			# if next multiple is empty end
	li t1, 0x3fc0
	and t1, t0, t1
	bnez t1, encodeLEB128Finish			# if second half is all uneeded 1 bits end
	ori t1, t1, 0x80				# set MSB to 1
	li a1, 2					# 2 bytes needed otherwise
	li t2, 0x3f80
	and t2, t0, t2					# get next 7 bits
	srli t2, t2, 7					# move to little endian
	slli t1, t1, 8					# move to litle endian
	or a0, t1, t2					# put two halves together
encodeLEB128Finish:
	jr ra						# return
	
#-------------------------------------------------------------------------------------------------------------------------#
# generateTargetTable
# This function initializes table(s) of counts and then computes all forward and backward branch target counts in the given RISC-V program. 
# Depending on the implementation there can either be one or two tables, however, if there are two, both must be generated here.
# Arguments:
# a0: Pointer to the binary representation of the RISC-V program.
#-------------------------------------------------------------------------------------------------------------------------#
generateTargetTable:
	addi sp, sp, -20
	sw ra, 0(sp)
	sw s0, 4(sp)					# address for fwdBranchTable
	sw s1, 8(sp)					# address for bwdBranchTable
	sw s3, 12(sp)					# current address
	sw s4, 16(sp)					# top of instr
	mv s3, a0
	mv s4, a0
	la s0, fwdBranchTable
	la s1, bwdBranchTable
	lw t0, 0(a0)					# get first instruction in binary form
generateTargetTableLoop:
	andi t1, t0, 0x7f				# isolate last 7 bits
	li t2, 0x63					# opcode for SB-type instruction
	bne t1, t2, generateTargetTableNext		# if current instruction is not SB-type go to next word
	li t3, 0xf00
	and t1, t0, t3					# immediate bits 1-4
	mv t2, t1
	srli t2, t2, 7					# put immediate into t2 and shift 1 to account for implicit 0 bit
	li t3, 0x7e000000
	and t1, t0, t3					# immediate bits 5-10
	srli t1, t1, 20					# move to correct spot
	or t2, t1, t2					# add bits 0-10 all together
	andi t1, t0, 0x80				# immediate bit 11
	slli t1, t1, 4					# move to correct spot
	or t2, t1, t2					# add bits 0-11 all together
	li t3, 0x80000000
	and t1, t0, t3					# immediate bit 12
	srai t1, t1, 19					# move to correct spot while sign extending
	or t2, t1, t2					# get full immediate
	mv a0, s4
	add a1, s3, t2					# get target instruction address
	srli a2, t2, 31					# get sign
	not a2, a2					# flip sign
	li t0, 0x1
	and a2, t0, a2
	jal ra, incrTargetCount				# increment the target
generateTargetTableNext:
	addi s3, s3, 4					# go to next word
	lw t0, 0(s3)					# get next instruction
	li t1, -1
	bne t1, t0, generateTargetTableLoop		# repeat if binary is not -1
	lw s4, 16(sp)
	lw s3, 12(sp)
	lw s1, 8(sp)
	lw s0, 4(sp)
	lw ra, 0(sp)
	addi sp, sp, 20
	jr ra						# return
#-------------------------------------------------------------------------------------------------------------------------#
# readTargetCount
# This function takes in the address of an instruction and returns the count of branch targets that have it as a target.
# Arguments:
# a0: Pointer to the binary representation of the RISC-V program.
# a1: Instruction address to get the count for.
# a2: Flag denoting whether the instruction is the target of a forward or backward branch; 1 = forward, 0 = backward.
# Return Values:
# a0: The associated count of how many branches have the given instruction as a target.
#-------------------------------------------------------------------------------------------------------------------------#
readTargetCount:
	sub t0, a1, a0					# find instr number
	beqz a2, readTargetCountBwd			# if a2 is 0 then find from bwd table
        la t1, fwdBranchTable
        add t0, t0, t1					# get index of instruction
        lb a0, 0(t0)					# get number of branches that it is a target of
        jr ra						# return
readTargetCountBwd:
	la t1, bwdBranchTable
	add t0, t0, t1
	lb a0, 0(t0)
	jr ra
#-------------------------------------------------------------------------------------------------------------------------#
# incrTargetCount
# This function takes in the address of an instruction and increments the count of branch targets that have it as a target by 1.
# Arguments:
# a0: Pointer to the binary representation of the RISC-V program.
# a1: Address of the instruction to increment the count for.
# a2: Flag denoting whether the instruction is the target of a forward or backward branch; 1 = forward, 0 = backward.
#-------------------------------------------------------------------------------------------------------------------------#
incrTargetCount:
	sub t0, a1, a0					# find instr number
	beqz a2, incrTargetCountBwd			# if a2 is 0 then find from bwd table
	la t1, fwdBranchTable
	add t0, t0, t1					# get index of instruction
	lb t1, 0(t0)					# get count
	addi t1, t1, 1					# increment
	sb t1, 0(t0)					# store count
	jr ra						# return
incrTargetCountBwd:
	la t1, bwdBranchTable
	add t0, t0, t1
	lb t1, 0(t0)
	addi t1, t1, 1
	sb t1, 0(t0)
	jr ra
